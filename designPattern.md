[TOC]
## 简介
- 设计模式（GOF模式）分为三种类型，共23类。
- 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。
- 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
- 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。

## 设计原则
- 封装变化： 找到程序中的变化内容并将其与不变的内容区分开。
- 面向接口
- 组合替代继承

## 创建型
### 单例
- 问题：每次请求都会建立链接，浪费资源
- 解决：控制住基类，使其仅能在首次调用时生成一个类，再次调用直接返回
- 适用：`配置`, `Session`, `Database`, `Cache`, `File`等一次请求被多个地方多次调用的类
- 特点：
    + 4私1公。私有静态属性(用于保存本类对象)，私有构造方法，私有克隆方法，私有重建方法，公共静态方法(用于获取本类对象)
    + 在应用请求的整个生命周期都有效
- 注意：优先考虑用`依赖注入`替代`单例`。

### 工厂
- 问题： 创建产品的代码和使用产品的代码耦合在一起；新增产品类型需要重写新的代码
- 方案： 创建工厂类，产品接口及类，分别实现。降低耦合提高扩展。

### 抽象工厂
- 问题： 若存在两位维度，就会有`产品`×`风格`个产品定义，创建`产品`冗余，使用复杂。
- 方案： 创建`接口及抽象工厂类`代替`工厂类`。每个`抽象工厂类`可创建对应`风格`的所有`产品`。

### 生成器 Builder
- 问题1： 构造函数的参数太多，且分散在客户端的各个部分，难以理解
- 方案1： 使用多个`withParam()`方法赋值参数，如此就将`实例化`和`参数赋值`分开
- 问题2： 对产品类的构建需要按多种参数顺序进行赋值，
- 方案2： 将`参数赋值`抽象为`主管接口`，每个类表示一种执行顺序供客户端调用

## 结构型
### 适配器
- 适用：当代码依赖一些`外部API`或`经常更改的类`时
- 注意：适配器模式中，适配器类的名称和创建方式一定是不会频繁改动的。对于客户端来说，引用适配器类的方式应该是统一而不变的，这才算是正确使用适配器。


## 行为型
### 观察者
- 简介：`观察者模式`也称`发布-订阅模式`，定义了一个被观察者和多个观察者的、**一对多**的对象关系。
- 使用：面向对象编程中，在被观察者状态发生变化的时候，它的所有观察者都会收到通知，并进行更新
- 作用：观察者模式通常用在实时事件处理系统、组件间解耦、数据库驱动的消息队列系统，同时也是MVC设计模式中的重要组成部分。
- uml图:{$root}/IMG/observerable.png

#### 问题
```php
// 订单类
class Order
{
    // 订单状态
    private $state = 0;

    // 订单状态有变化时发送通知
    public function addOrder()
    {
        $this->state = 1;
        // 发送邮件
        Email::update($this->state);
        // 短信通知
        Message::update($this->state);
        // 记录日志
        Log::update();
        // 其他更多通知
    }
}

// 客户端
$order = new Order();
$order->addOrder();
```

- 例：订单支付成功后，短信/邮件通知用户，并记录日志。代码如上
- 如果没用观察者模式会有以下具体问题违反`开闭原则`：
    + 若加一种通知方式，如系统消息通知，则除了增加新类，同时还需要修改Order类和客户端
    + 若订单不需要某种通知，比如不需要记录日志，则必须修改Order类，做状态的判断；
- 订单类与多个通知类耦合高：订单类会因为通知类变化而修改

#### 解决
- 例：订单支付成功后，短信/邮件通知用户，并记录日志。
    + 被观察者：订单
    + 观察者：短信/邮件/日志
    + 状态变化：支付成功
    + 更新：通知用户/记录日志
- 优点：解耦，被观察者完全不需要关心观察者。
    + 在使用观察者模式后上述解决办法就是增加/删除观察者。
- 被观察者接口/类：除了必要的attach()、detach()、notify()三个方法外，部分观察者的更新需要一些参数，这些参数通过方法来传递，如getState。
- 客户端代码
```php
// 创建观察者对象
$email = new Email();
$message = new Message();
$log = new Log();
// 创建订单对象
$order = new Order();

// 向订单对象中注册3个观察者：发送邮件、短信通知、记录日志
$order->attach($email);
$order->attach($message);
$order->attach($log);
// 添加订单，添加时会自动发送通知给观察者
$order->addOrder();

echo '<br />';

// 删除记录日志观察者
$order->detach($log);
// 添加另一个订单，会再次发送通知给观察着
$order->addOrder();
```