[TOC]
# cache缓存
- 文件缓存
- 外存类型非关系数据库：mogoDB
- 内存型非关系数据库：redis,memcache
- RocksDB

## 键值数据库的组成
- 访问框架，包括`动态库访问`(rocksDB)和`网络访问框架`(redis, memcached)两种类型
- 操作模块`put/get/scan/delete`
- 存储模块 可能含有`分配器`和`持久化`
- 索引模块

### I/O模型设计
此时，我们会遇到一个系统设计上的问题，简单来说，就是网络连接的处理、网络请求的解析，以及数据存取的处理，是用一个线程、多个线程，还是多个进程来交互处理呢？该如何进行设计和取舍呢？我们一般把这个问题称为 I/O 模型设计。不同的 I/O 模型对键值数据库的性能和可扩展性会有不同的影响。

### 索引模块：实现索引的数据类型
- B+树: `mysql`
- 跳表: `RocksDB`
- 哈希表: 如memcache, redis等`内存键值数据库`，其采用`哈希表`的主要原因在于键值数据保存在内存中，而内存的高性能随机访问特性可以很好地与`哈希表` O(1) 的时间复杂度相匹配。
- 字典树

### 操作模块
- `scan`: 根据一段 key 的范围返回相应的 value 值。
- `GET/SCAN` 只需要根据`value`的存储位置返回`value`值即可；
- `PUT` 写入一个新的键值对数据而言，需要为该键值对分配内存空间；
- `DELETE`需要删除键值对，并释放相应的内存空间，这个过程由分配器完成。

# redis
## redis数据结构
- 键值中`value`的5种`数据类型`是由其6种`底层数据结构`实现的
- 底层数据结构包括：`简单动态字符串`,`双线链表`,`压缩列表`,`哈希表`,`跳表`,`整数数组`
- `value`的`数据类型`：string, hashes, list, sorted set, set 后5种都有两种`底层数据结构`，所以被称为`集合类型`。其特点是一个键对应了一个集合的数据。
- `string` 由`简单动态字符串`组成
- `hashes` 由`哈希表`和`压缩列表`组成
- `list` 由`双向链表`和`压缩列表`组成
	+ 仅当FIFO/LIFO时使用，队首尾元素操作仅为`O(1)`，其他元素为`O(N)`
- `sorted set` 由`跳表`和`压缩列表`组成
- `set` 由`哈希表`和`整数数组`组成
	+ 范围操作应当用`SCAN`代替

### redis键值的组织结构：`hash-table`
- `key`与`value`的映射关系使用`哈希表`存储，但`value`有多种数据类型，所以实际上`hash-bucket`中的`entry`存储的是`指针`。
- `entry`表示`哈希冲突链`(即hash-bucket链表)中的每个元素，其结构为`{*key, *value, *next}`
- 大数据量时出现的`哈希冲突`会导致查询kv变慢，因此需要对哈希表做`rehash`操作
	+ 要想找到长度为100的链表的最后一个kv就要101次查询，时间复杂度为O(n)

### rehash
- rehash本质是减少`哈希冲突链`元素，增加`hash-bucket`数量
- 实现方式：redis使用了两个全局哈希表A和B。当A数据增多时执行rehash
	1. 给B分配更大的空间(如2倍于1的大小)
	2. 把A中的数据`重新映射`并`拷贝`到B中
	3. 释放A的空间留作下次rehash扩容备用
- 这里有个隐患，即第2步的`拷贝`会阻塞redis线程，因此redis采用了`渐进式rehash`
- `渐进rehash`: 在第二步拷贝数据时redis正常处理客户端请求，从第1个索引开始每次处理请求将索引i对应的`哈希冲突链`的所有`entries`重新映射并拷贝到B中；下次请求处理i+1直到全部rehash后释放A空间。

### 集合类型
- `压缩列表`: 类似数组区别在于其表头有三个字段`zlbytes`(长度), `zltail`(列表尾偏移量), `zllen`(entry数量)；表尾有一个字段`zlend`(结束标志)。其时间复杂度为`O(N)`
	+ 当获取头尾数据时可通过头尾字段长度直接定位，此时时间复杂度为`O(1)`
- `跳表`: 在链表的基础上增加了多级索引，通过索引位置的跳转实现数据的快速定位，其时间复杂度为`O(logN)`

#### 集合类型的操作类型
- 集合常见操作类型很多，其复杂度各不相同。通过如下技巧规避高复杂度的操作
- `单元素操作` 指每种集合类型对单个数据实现的CURD操作，其时间复杂度根据集合采用的`数据结构`决定，结合的多元素操作时间复杂度=数据结构复杂度x元素个数，如`HMGET`复杂度为`O(M)`
- `范围操作`指集合中的`遍历`可返回集合中所有数据，其时间复杂度一般为`O(N)`。较为耗时应当避免。如`HGETALL`,`SMEMBERS`,`LRANGE`,`ZRANGE`
	+ 2.8版本后redis提供的`SCAN`系列操作实现了`渐进式遍历`，每次返回有限数量的数据。避免了获取全量数据导致的阻塞。
- `统计操作`指集合类型对集合中所有元素个数的记录，其时间复杂度为`O(1)`。如`LLEN`,`SSCARD`


## 单线程
- 单线程redis指`网络IO`和`键值对读写`是由一个线程来完成的(这是对外提供键值存储服务的主要流程)。至于其他功能(如持久化、异步删除、集群数据同步等)由额外的线程执行

### 使用单线程的原因
- 多线程处理`共享资源`面临`并发访问控制`问题，引入`同步机制`会带来额外开销
- 解决`网络IO`的性能瓶颈：`多路复用`在`网络IO`时并发处理客户端请求
- 解决`键值对读写`性能瓶颈：使用`内存`+`hash-table`存储键值地址+各个类型`数据结构`优化

### 多路复用



## redis性能好的原因
- Redis 采用一些高效的`索引结构`作为某些`value`类型的底层数据结构。
- 单线程(怎么实现单线程还非阻塞的)，避免了频繁切换的上下文和sync问题
- 采用了非阻塞I/O多路复用机制
- 内存型非关系数据库

## 持久化机制
- redis持久化有`rdb`(默认)和`aof`两种策略。可同时开启两种策略，此时redis会优先选择`aof`恢复
- RDB实现方式：定时fork子进程将`data`保存在快照文件`dump.rdb`中，并替换旧的快照。可通过配置`save`参数定义快照保存周期。
- RDB优缺点
	+ 有数据丢失风险，无法实时持久化
	+ IO性能弱，数据量大时效率低
	+ `dump.rdb`文件小恢复更快
- AOF类似mysql的binlog：1s/次fsync，将`写命令`添加到`aof文件`的最后，当redis重启时执行该文件的`写命令`重建数据库内容
- AOF优缺点
	+ 数据丢失风险低，写入性能高，文件不易破损
	+ 适合做灾难性丢失的紧急恢复，但`aof文件`更大，恢复更慢

## 缓存相关定义
- 缓存雪崩：旧缓存失效新缓存未设时，查询都走数据库给CPU和内存都造成巨大压力
	+ 例如：设置缓存时采用相同的过期时间，以至于在同一时刻出现大面积的缓存过期。
	+ 解决1：设置缓存时分散缓存失效时间
	+ 解决2：用`锁`或`队列`保证同时刻不会有大量线程对数据库一次性进行读写
- 缓存穿透： 缓存和数据库中都没数据，导致两次无用查询
	+ 解决1：布隆过滤器，将所有可能的值哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。
	+ 解决2：缓存空数据
- 缓存预热：服务上线后直接将缓存加载到缓存系统。
	+ 实现方式：数据量不大的方式可以使用启动预加载；定时刷新；手动刷新等。
- 缓存降级：当缓存出现问题时为保证可用，对关键数据进降级。

## 过期策略&内存淘汰机制
- `定期删除`(默认)： 每100ms检查是否有过期key则删除(随机抽取检查)
- `惰性删除`： 系统查询的时候会检查key有没有过期，若过期了就删除
- redis采用`定期删除`+`惰性删除`策略，但任然存在既定期删除遗漏也未被查询的数据，因此需要引入`redis内存淘汰机制`

### redis数据淘汰机制
当内存达到最大内存限制时进行的数据淘汰策略，有如下选项

- 新写入操作报错(默认)
- 在键空间中，移除最近最少使用的key(LRU推荐)
- 在键空间中，随机移除某个key
- 在设置过期时间的键空间中，移除最近最少使用的key。(把redis既当缓存又做持久化的时候才用)
- 在设置过期时间的键空间中，随机移除某个key
- 在设置过期时间的键空间中，按过期时间优先移除。

