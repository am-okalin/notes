[TOC]
## shell简介
### shell简介
- shell是一个命令行解释器，为用户提供了一个向Linux内核发送请求(用于运行程序)的界面系统级程序，用户可以用shell来启动，挂起，停止一些程序
- shell还是一个功能强大的编程语言，易编写易调试灵活性强。shell是解释型脚本语言，在脚本中可直接调用linux系统命令
- shell有两种语法:`bourne`(linux)与`C`(unix),着两种语法彼此不兼容
    + `Bourne`家族包括 `sh` `ksh` `Bash` `psh`
    + `C`家族包括 `csh` `tcsh`
- 通过`/etc/shells`文件可查看系统支持哪些shell 
- 查看`$SHELL`变量，得知当前系统用的是哪一种shell。
- 系统启动后就会进入的shell是父shell。可通过输入shell名称调用子shell。
- `pstree` 查看进程树，可通过此命令知道当前shell是不是子shell


### Bash基础
#### 脚本执行方式
- `chmod 755 hello.sh`赋予执行权限，`./hello.sh`使用相对路径或绝对路径直接运行
- `bash hello.sh`通过Bash调用执行脚本

#### 命令生效顺序
1. 绝对/相对路径执行的命令
2. 别名
3. Bash的内部命令如`cd`
4. 按`$PATH`环境变量定义的目录查找顺序 找到的第一个命令

#### 别名alias
- `alias 别名 = '原命令'` 定义/修改别名，不加参数可查看所有别名
    + `unalias 别名` 删除别名
    + 定义别名再重启机器后会丢失，将别名写入环境变量配置文件`~/.bashrc`，启动时载入
    + 使用`source .bashrc` 重新加载`~/.bashrc`文件，立即生效
- 别名生效顺序相对较高，别名不能与其他命令相同 有可能覆盖其他命令

#### Bash中的常用快捷键
- `ctrl+l` 清屏
- `ctrl+c` 终止命令
- `ctrl+a` 光标移至行首
- `ctrl+e` 光标移至行尾
- `ctrl+u` 从光标所在位置删除到行首
- `ctrl+r` 在历史命令中搜索
- `ctrl+z` 把命令放入后台

#### 历史命令
- 历史命令的调用
    + 使用上下箭头调用以前的历史命令
    + 使用"!n"重复执行第n条历史命令
    + 使用"!!"重复执行上一条命令
    + 使用"!str"重复执行最后一条str开头的命令
- `history [option]`历史命令操作
    + 不加任何参数查看历史命令
    + `-c` 清空历史命令
    + `-w` 把缓存中的历史命令写入`~/.bash_history`历史命令保存文件
- `~/.bash_history`用户正确登出后才会把命令写入其中
- 内存中历史命令默认保存1000条，可在环境变量配置文件`/etc/profile`中修改`HISTSIZE`参数

#### 重定向
##### 标准输入输出
|  设备  | 设备文件名  |  文件描述符  |              类型/说明               |
|--------|-------------|--------------|--------------------------------------|
| 键盘   | /dev/stdin  | 0(输入默认)  | 标准输入                             |
| 显示器 | /dev/stdout | 1(输出默认)  | 标准输出                             |
| 显示器 | /dev/stderr | 2            | 标准错误输出                         |
| 无     | /dev/null   | 无(输入默认) | 丢弃写入数据，读取回得到EOF          |
| 无     | /dev/zero   | 无(输出默认) | 输出空字符流(NULL, ASCII NULL, 0x00) |

##### 输出重定向
- `date >file`标准输出重定向
    + `>`  覆盖文件内容
    + `>>` 追加文件内容
- `daterror 2>>file` 标准错误输出重定向
    + 通常命令错误会将错误输出到终端上，在输出符号`>>`前加`2`(文件描述符)就可以将错误信息输出到文件中
- `ls >>file 2>>errorfile` 正确错误分别输出到两文件
- `ls >>file 2>&1` 正确错误都输出到一个文件
- `ls &>>file` 正确错误都输出到一个文件

##### 输入重定向
- `wc [option] [filename]` 字符串统计
    + `-l` 统计行数    
    + `-w` 统计单词数
    + `-c` 统计字节数
    + 不加参数，不加文件，使用`ctrl+D`中止输入进行统计
    + `wc file` 等同于 `wc < file`
- `命令 <文件`把文件内容作为命令的输入
- `命令 <<标识符 info 标识符`将标识符之间的内容作为命令的输入

#### 管道符
##### 多命令执行顺序
- `command1 ; command2`  顺序执行，命令间没有任何逻辑关系
- `command1 && command2` 逻辑与，命令1正确执行，命令2才会执行
- `command1 || command2` 逻辑异或，命令1错误执行，命令2才会执行
- `command && echo yes || echo no`若命令正确输出yes，若命令错误输出no
- 命令执行是否正确是根据 预定义变量`$?`判断的

##### 管道符`|`
- `command1 | command2` 命令1的标准(正确)输出作为命令2的标准输入
- `ls -l /etc | more` 分屏展示/etc目录下的内容
    + `more`命令用于分屏展示文件内容
- `netstat -an | grep ESTABLISHED | wc -l`统计连接本机器的数量
    + `netstat -an` 查看系统中的所有网络连接

#### Bash中的特殊符号
- 通配符
    + `?` 匹配一个任意字符
    + `*` 匹配0或多个任意字符
    + `[]` 匹配括号中任意一个字符
    + `[-]` 匹配括号中范围包括的任意字符`[a-z]`
    + `[^]` 匹配除括号中以外的字符
- 其他符号
    + `#` 注释
    + `\` 转义符
    + `$` 调用变量的值 例`echo $var`
    + `$()` 等同于` `` ` 例`var = $(command)`变量赋值时将command的结果赋值给var
    + ` `` ` 反引号中的内容是系统命令，在Bash中会先执行它，推荐使用`$()`
    + `''` 单引号中所有特殊符号都没有特殊含义
    + `""` 双引号中`` `$\ ``具有特殊含义，其他没有


### 变量
- 环境变量：变量名可自定义，可更改值，但对系统生效的环境变量名和变量作用是固定的
- 预定义变量：在bash中已经定义好的变量，变量名不能自定义，作用是固定的
- 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的

#### 用户自定义变量
- 只可以在当前shell中生效(局部变量)
- 在bash中，变量的默认类型都是字符串型，变量运算需要用`$(())`
- `$(())` 在括号内进行数值计算
- 变量叠加：使用`""`或`${}`可叠加变量
- `$` 调用变量
- `unset` 删除变量，删除时不需要加`$`
- `set` 查看所有变量
    + `-u` 调用未申明变量时会报错

```shell
x=1
x="$1"2
x=${x}3
echo $x
unset x
echo $x
set -u
echo $x
```

#### 环境变量
##### 自定义环境变量
- 用于定义每个用户的操作环境
- 可以在当前shell及子shell中生效
- 环境变量为了与普通变量区分，建议大写
- `export var=value` 或 `var=value && export var` 自定义环境变量
- `env` 查看环境变量， 使用`set`查看所有变量也会包含环境变量
- 删除自定义环境变量时，要退回到定义它的shell中进行删除，否则会报错

##### 对系统生效的环境变量
- 变量名和变量作用是固定的，以下是一些常用环境变量
- `HOSTNAME`: 主机名
- `SHELL`: 当前shell
- `TERM`: 终端环境
- `HISTSIZE`: 历史命令最大条数
- `SSH_CLIENT`: 当前操作环境使用ssh连接的，这里记录客户端IP
- `SSH_TTY`: ssh连接的终端
- `USER`: 当前登录的用户
- `PATH`: 多个目录组成以`:`分割，是系统查找命令的路径
    + 使用变量叠加追加值`PATH="$PATH":/dir`
- `PS1`: 命令提示符设置，较特殊需用`set`才能看见
    + `\d`: 显示日期，格式为"week month year"
    + `\H`: 显示完整主机名
    + `\t`: 显示24小时制的时间，`HH:MM:SS`
    + `\A`: 显示24小时制的时间，`HH:MM`
    + `\u`: 显示当前用户名
    + `\w`: 显示当前目录的完整名称
    + `\W`: 显示当前目录的最后一个目录名
    + `\$`: 提示符，root显示#，普通用户显示$
- `PS2`: 多行命令输入符。 例`ls \`输入后可多行输入

##### 语系变量
- `locale` 查询当前系统语系
    + `-a`: 查看linux支持的所有语系,用`locale -a | more`翻页查看
- `LANG`: 定义系统主语系的变量，若改变则临时生效，重启失效
- `LC_ALL`: 定义整体语系的变量
- `/etc/sysconfig/i18n` 系统默认语系文件，重启就会加载此文件
- linux中文支持。安装系统时正确安装中文语系及字体，若没有则要安装
    + 若有图形页面，可正确支持中文显示
    + 使用远程工具连接，只要语系正确，可支持中文显示
    + 若使用纯字符页面，必须使用第三方插件(如zhcon)

#### 预定义变量
| 变量 |                            作用                            |
|------|------------------------------------------------------------|
| `$?` | 最后执行的命令的返回状态，为0说明正确执行，非0说明错误执行 |
| `$$` | 当前进程的进程号(PID)                                      |
| `$!` | 后台运行的最后一个进程的进程号(PID)                        |

#### 位置参数变量
| 变量 |                                 作用                                 |
|------|----------------------------------------------------------------------|
| $n   | n为数字，$0代表命令本身，$1-$9代表1-9个参数，十以上的参数用${10}表示 |
| $*   | 代表命令行中所有参数，$*把所有参数看成一个整体                       |
| $@   | 代表命令行中所有参数，$@把每个参数区分对待                           |
| $#   | 代表命令行中所有参数的个数                                           |

- 位置参数变量属于特殊的预定义变量
- 位置参数变量写的脚本只适合写作者使用，不适合第三方使用
- 脚本开头必须以`#!/bin/bash`作为第一行，申明使用bourne语法
- 例子如下
```shell
#!/bin/bash
# 输出个数
echo $#
# 相加
sum=$(($1+$2))
echo $sum
# 参数为整体 循环1次
for i in "$*"
    do
        echo $i
    done
# 参数不为整体 循环$#次
for i in "$@"
    do
        echo $i
    done
```

#### 键盘输入命令`read`
- `read [option] [var]`接收键盘输入数据，用于写脚本给第三方使用，可替代位置参数变量
- `-p "提示信息"` 在等待read输入时，输出提示信息
- `-t 秒数` 指定等待用户输入的时间
- `-n 字符数` 只接受指定的字符数量
- `-s` 隐藏输入的数据，适用于机密信息输入


### 运算符
#### declare命令
- `declare [+/-] [选项] var` 用于声明变量类型
    + `-` 给变量设定类型属性
    + `+` 取消变量的类型属性
    + `-a` 将变量声明为数组型
    + `-i` 将变量声明为整型
    + `-x` 将变量声明为环境变量
    + `-r` 将变量声明为只读变量
    + `-p` 显示指定变量的被声明类型
- 声明数组变量
```shell
# 以下是两种定义数组元素的方法
arr[0]=val0
declare -a arr[1]=val1
# 默认输出arr[0]
echo ${arr}
# 输出指定下标
echo ${arr[1]}
# 输出数组全部
echo ${arr[*]}
```
- 声明环境变量用的`export var=val`实际上是调用了`declare -x var=val`
- `declare -r var` 赋予`var`只读属性，这会使变量不能修改删除，甚至不能取消只读属性

#### 数值运算方法
- `declare -i c=$a+$b` ab可以不用声明为整形，只要计算c时声明即可
- `expr`或`let`工具，两工具语法基本一致。
    + 例`c=$(expr $a + $b)`
    + 运算符`+`左右两侧是有空格的
- `$((运算式))`或`$[运算式]`
    + 例`c=$[$a+$b]`

### 环境变量配置文件
#### 准备知识
- `环境变量配置文件`用于定义默认操作环境，如`PATH`
- `source`重新加载配置文件别名`.`
    + 修改配置文件后必须注销重新登录才会生效，使用source命令可以不用重新登录
    + `source etcfile`或`. etcfile` 其中`.`就等同于source命令
- `umask`查看系统默认权限
    + 文件最高权限为666
    + 目录最高权限为666
    + 权限不能使用数字进行换算，而必须使用字母
    + umask定义的权限是系统默认权限中准备丢弃的权限，如umask=022是丢弃本人外的w权限

#### 加载配置文件
- `/etc/profile`文件在登录时按顺序加载以下文件
    + `->` `/etc/profile.d/*.sh`(其中`lang.sh`会加载`/etc/sysconfig/i18n`)
    + `->` `~/.bash_profile` `->` `~/.bashrc` `->` `/etc/bashrc`
- su切换用户加载：`/etc/bashrc` `->` `/etc/profile.d/*.sh`
- 调用顺序中缺少了文件就不会调用后续文件，如缺少`~/.bashrc`是不会调用`/etc/bashrc`的
- `/etc/bashrc`是否加载`/etc/profile.d/*.sh`，取决于有无登录过程

#### 其他配置文件
- `~/.bash_logout` 注销时生效的环境变量配置文件
    + 很少用到所以这个文件初始时是空的
    + 在注销时要清空历史命令，则可用到这个文件
- `~/.bash_history` 用于保存历史命令
    + 用户操作的历史命令保存在内存中，用户注销时会写入此文件
- `/etc/issue` 本地终端登录前展示信息，可使用转义符展示机器的部分信息
- `/etc/issue.net` 远程终端登录前展示信息,这是`ssh服务`的一个配置文件
    + 转义符在此文件中不生效
    + 是否显示此欢迎信息由`/etc/ssh/sshd_config`决定，加入`Banner /etc/issue.net`后`service sshd restart`重启`ssh服务`生效
- `/etc/issue` 本地终端登录前展示信息
- `/etc/motd` 登陆后欢迎信息


## 服务管理-systemV
### 系统的运行级别
- 系统运行级别 通过`init n`切换/执行系统运行级别
    + 0 关机
    + 1 单用户 启动最小程序的单用户模式多用于系统修复
    + 2 不完全多用户 不含NFS服务 NFS是linux中的一个文件共享服务
    + 3 完全多用户 我们常用的cli模式
    + 4 系统保留 未分配 
    + 5 图像页面 这个前提是得装了图形页面
    + 6 重启
- `runlevel` 查看运行级别
- 修改`/etc/inittab`指定默认运行级别，如添加`id:3:initdefault:` 指定开机后进入完全多用户cli模式

### IP管理工具
- 查看`/etc/services`了解服务与端口对应情况
- `netstat` 用于查看网络状态
    + `-a` 列出全部服务
    + `-t` 列出tcp数据 
    + `-u` 列出udp数据
    + `-l` 列出状态为`listen`的服务
    + `-n` 显示IP地址和端口号，而不是显示域名和服务名
    + `-p` 列出该服务的PID

### RPM包服务
#### 默认安装位置
- `/etc/` 配置文件位置
- `/etc/sysconfig/` 初始化环境配置文件位置
- `/etc/init.d/` 启动脚本的位置
- `/etc/xinetd.conf` xinetd配置文件
- `/etc/xinetd.d/` 基于xinetd服务的启动脚本
- `/var/lib/` 服务产生的数据存放处
- `/var/log/` 日志

#### 独立服务管理
- `/etc/init.d/filed.sh start/reload` 直接操作`.sh`文件管理服务
    + `/etc/init.d`是`etc/rc.d/init.d`的软链接，用于存放系统服务的管理脚本
- `service name start/reload` 通过`service`命令管理服务
    + `service`命令实际上就是执行`/etc/init.d`目录中的脚本

##### 服务自启动
- `/etc/rc.d/rc.local`文件是在所有服务启动后，用户登录之前最后执行的脚本。
    + 在此文件中添加启动服务命令，可完成开机自启动如添加`/etc/init.d/httpd start`
- `chkconfig` 查看操作服务自启动状态
    + `--list` 查看服务自启动状态，显示服务名与系统运行级别
    + `--level 2345 httpd on/off` 设置apache服务自/不启动 `--level`默认2345可省略

#### 基于xinetd服务管理
- `xinetd`是超级守护进程用于管理一些后台服务，用户访问这些后台服务要通过`xinetd`
- `xinetd`虽然消耗内存少，但是操作服务慢，所以越来越少的服务通过`xinetd`管理
- 安装`xinetd`后，可通过`chkconfig --list`查看`xinetd`管理服务的启动状态
- 修改`/etc/xinetd.d/`目录下对应服务的文件 来控制服务是否启动。修改后执行`service xinetd restart`重启生效
- `chkconfig` 用于管理服务状态(注意：是管理启动状态，不是管理自启动状态)
    + `chkconfig service on/off`是直接操作`基于xinetd的服务`状态的，且不能加`--level`参数，加了会报错。
- 通过`netstat -utlnp`查看服务对应端口是否启动


### 源码包服务管理
- 要设置源码包服务自启动，可以直接在`/etc/rc.d/rc.local`文件中加入`/usr/local/apache2/bin/apachectl start`
- 由于源码安装所以要从安装目录启动服务`/usr/local/apache2/bin/apachectl start/stop`
- 让源码包服务被service识别，只要在service启动路径中加上源码包的软链就行`ln- s /usr/local/apache2/bin/apachectl /etc/init.d/apachectl`
- 让apache服务被chkconfig识别
    + 编辑`/etc/init.d/apachectl`(完成上面的软链操作后)，在脚本中添加以下内容
```shell
# 注: `chkconfig: 运行级别 启动顺序 关闭顺序` 指定本脚本可被chkconfig命令管理
# chkconfig: 35 86 76
# description: source package apachectl .....
```
    + `chkconfig --add apachectl` 添加apachectl到chkconfig命令



## 服务管理-systemd
### 简介
[官方手册中文翻译](http://www.jinbuguo.com/systemd/systemd.index.html)
- `systemd`是一系列工具的集合，用于启动操作系统，接管后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责
- `systemd`接管了服务管理与系统管理，并且兼容旧的`sysVinit`

### 启动
- linux内核首先执行`/usr/lib/systemd/systemd`，这个程序会按顺序依次发起其他程序
- 在终端中输入`ps aux`看到PID为1的进程就是`systemd`。或用`pstree`也可看出`systemd`启动了其他进程
- `systemd`出现之前系统内核会去运行`/sbin/init`，随后这个程序会在名为`sysVinit`的系统中运行其余的各种启动脚本。
    + 所以在centos6执行`pstree`看到的所有进程的父进程就是`init`
    + `systemd`部分兼容了`sysVinit`

### 单元(unit)
- `unit`是一些存有关于服务`service`、设备、挂载点、和操作系统其他方面信息的配置文件。
- `systemctl list-unit-files`列出linux系统上的所有单元
    + `disabled` 表示被禁用
    + `enabled` 表示被启用(不等于对应的服务正在运行，而只能说明它可以被开启)
    + `static` 是其他单元所依赖的对象，不能直接启用
- `unit`包含很多，若只想看服务可以使用`systemctl list-unit-files --type=service`
- `systemctl status gdm.service`查看对应服务状态，获取该服务的信息
- `/usr/lib/systemd/system/`目录下存放了单元的配置文件

### 配置文件
- `pkg-config`用于获得已安装库/模块的编译信息。使用`pkg-config systemd --variable=`获取`systemd`中指定变量的值。
    + `systemdsystemunitdir` 软件包安装系统单元文件的默认目录
    + `systemdsystemconfdir` 优先级最高的系统单元目录
    + `systemduserunitdir` 软件包安装用户单元文件的默认目录
    + `systemduserconfdir` 优先级最高的用户单元目录

### 使用
```shell
# 查看服务状态
systemctl is-active sshd.service

# 结束服务进程(服务无法停止时)
systemctl kill mysqld

# 查看启动失败的服务列表。
systemctl  --failed
```

## 系统管理
### 进程管理
#### ps与pstree查看进程命令
- `ps -le` 或 `ps aux` 都可用于查看进程信息
- `ps`BSD操作系统格式
    + `a` 显示一个终端的所有进程，除了会话引线
    + `u` 显示进程的归属用户及内存使用情况
    + `x` 显示没有控制终端的进程
- `ps`标准命令格式
    + `-l` 长格式显示更详细的信息
    + `-e` 显示所有进程等 同于`-A`
    + `-f` 显示用户id，进程id，父进程id，最近CPU使用情况，进程开始时间等
- `ps aux`命令输出
    + `COMMAND` 产生此进程的命令名
    + `START` 进程启动时间
    + `TIME` 进程占用CPU运算时间(时间片累加) 值越大越耗费资源
    + `USER` 产生此进程的用户 
    + `STAT` 进程状态: `R`运行  `S`睡眠  `T`停止  `s`包含子进程  `+`位于后台
    + `%CPU` 占用CPU资源的百分比
    + `%MEM` 占用物理内存的百分比
    + `PID` 进程的ID
    + `VSZ` 占用虚拟内存的大小 单位KB
    + `RSS` 占用实际物理内存的大小 单位KB
    + `TTY` 进程运行的终端，tty1-6本地字符终端，tty7本地图形终端，pts/0-255指虚拟终端，`?`指该进程有内核直接启动
- `pstree` 查看进程树
    + `-p` 显示进程PID
    + `-u` 显示进程所属用户

#### top命令 判断系统健康状态
- `top [option]` 查看进程 判断系统健康状态
    + `-d` 秒数：指定top命令每隔几秒刷新，默认3秒
    + `-b` 使用批处理模式输出，一般和`-n`选项合用
    + `-n` 次数：指定top命令执行次数，一般和`-b`选项合用
- `top` 交互模式中的可执行命令
    + `?`或`h` 显示交互模式帮助
    + `P` 以CPU使用率排序，默认就是此项
    + `M` 以内存使用率排序
    + `N` 以PID排序
    + `q` 退出
- `top` 第一行判断系统健康状态的指标
    + `H:i:s` 系统当前时间
    + `up 1 day, 13:32` 系统已运行时间 已运行1天13小时32分钟
    + `2 user` 当前登录用户数
    + `load acerage: 0,0,0` 系统在前1,5,15分钟的平均负载，大于CPU核心数表示超出负荷
- `top` 第二行 进程数
    + `tasks: 95 total` 总进程数
    + `1 running` 正在执行的进程数
    + `90 sleeping` 睡眠的进程数
    + `0 stopped` 正在停止的进程数
    + `0 zombie` 僵尸进程数。若存在僵尸进程，则需要手工检查僵尸进程
- `top` 第三行 CPU占用百分比
    + `cpu(s): 0.1%us` 用户模式 占用CPU百分比 
    + `0.1%sy` 系统模式 占用CPU百分比
    + `0.0%ni` 改变过优先级的用户进程 占用的CPU百分比
    + `99.7%id` 空闲CPU的 占用CPU百分比 不能低于20%
    + `0.1%wa` 等待输入/输出的进程的 占用CPU百分比
    + `0.0%hi` 硬中断请求服务
    + `0.1%si` 软中断请求服务
    + `0.0%st` (steal time)虚拟时间百分比 就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比
- `top` 第四行 物理内存占用(单位KB): `total`全部内存数量, `used`使用内存数量, `free`空闲内存数量, `buffers`缓冲内存数量(加速数据写入)
- `top` 第五行 虚拟内存(交换分区)占用(单位KB): `total`全部内存数量, `used`使用内存数量, `free`空闲内存数量, `cached`作为缓存的交换分区大小(加速数据读取)
- 判断系统健康状态主要通过 平均负载, cpu空闲率, 物理内存空闲数, 虚拟内存空闲数来判断
- `top -b -n 1 > path/top.log` 将所有top信息输出到log中

#### 杀死进程
##### 信号
| n  |  signal |                  signal description                 |
|----|---------|-----------------------------------------------------|
|  1 | SIGHUP  | 关闭进程，重新读取配置文件后重启，可平滑重启服务    |
|  2 | SIGINT  | 终止信号，用于中止前台进程。等同`ctrl+c`            |
|  3 | SIGQUIT | 键盘产生的中断,即`ctrl+c`                           |
|  8 | SIGFPE  | 运算错误信号。如浮点运算错误 溢出 除0错误等         |
|  9 | SIGKILL | 强制中止信号。不能被阻塞/处理/忽略                  |
| 10 | SIGUSR1 | 用户信号，进程可自定义用途                          |
| 12 | SIGUSR2 | 用户信号，进程可自定义用途                          |
| 14 | SIGALRM | 时钟定时信号。计算时钟时间 alarm函数使用该信号      |
| 15 | SIGTERM | 正常结束信号。`kill`默认信号，若无法中止才尝试信号9 |
| 18 | SIGCONT | 恢复暂停的进程。该信号不可被阻断                    |
| 19 | SIGSTOP | 暂停前台进程。等同`ctrl+z`。该信号不可被阻断        |

##### 杀死进程命令
- 在重启服务时不希望中断连接用户，可使用`SIGHUP`信号重启。如生产环境的apache服务。
- `kill [option] [signal] [PID]` 用于杀死单一进程 如`kill -1 1234`
    + `-I` 忽略进程名大小写
    + `-i` 交互式，询问是否要杀死某个进程
    + `-l` 查看可用的进程信号。 用此选项后面不加任何参数
- `killall [option] [signal] 进程名` 按进程名杀死多个进程 如`killall -i -1 httpd`
    + `-I` 忽略进程名大小写
    + `-i` 交互式，询问是否要杀死某个进程
- `pkill [option] [signal] 进程名` 按进程名杀死多个进程
    + `-t 终端号` 根据终端号踢出用户
- `w` 查看当前登录用户
    + 用此命令查看每个用户的终端号，提供给`pkill`命令用于踢出用户

#### 修改进程优先级
- 每个cpu核心在一个时钟周期内只能运算一个指令，进程优先级决定了每个进程处理的先后顺序
- `ps -le`查看进程 有两列`PRI`与`NI`,这两个值都是优先级，数字越小代表该进程越优先
    + `PRI` 代表priority 不可修改，最终系统生效的是`PRI`=`PRI`+`NI`
    + `NI` 代表nice 可修改，范围是`-20`至`19`
    + 普通用户只能调高`NI`值，而不能降低，如原本`NI`为0，则只能调整为大于0；
    + root用户才能设定进程`NI`值为负，而且可以调整任何用户的进程
    + PRI(最终值) = PRI(原始值) + NI
- `nice [option] 命令`给新执行的命令赋予NI值，但不能修改已存在进程的NI值
    + `-n NI值` 给命令赋予NI值
    + 如 `nice -n -5 service httpd start`
    + 不能修改已存在进程的优先级
- `renice [优先级] PID` 修改已存在进程的NI值的命令
    + 如 `renice -10 2125`
- 通常情况下没必要去修改优先级

### 工作(job)管理
#### 概念
- 若希望某些命令执行不占用终端，可把它放入后台进行管理，此进程被称为job
- 工作管理指的是在单个终端中同时管理多个工作(job)的行为。
- 放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，不能执行
- 终端与job是一对多绑定的，若终端关闭会给每个job发送`SIGHUP`信号关闭该进程。所以该终端不可以管理其他终端的job

#### 管理方法
- `&` 可把命令放入后台执行 如`tar -zcfetc.tar.gz/etc &`
    + 若放入后台的命令与前台有交互，那么该命令也会被暂停
- `ctrl+z` 把命令放入后台暂停 如执行`top`后按`ctrl+z`就会将`top`命令暂停
- `jobs [option]` 查看有多少个在后台运行的命令
    + `-l` 显示工作的PID
    + `-`表示倒数第二个放入后台的工作
    + `+`表示最近一个放入后台的工作，也是工作恢复时，默认恢复的工作
- `fg %工作号` 将后台暂停的工作恢复到前台执行
    + [%工作号] `%`可省略，工作号用`jobs`查看
- `bg %工作号` 将后台暂停的工作恢复到后台执行
    + [%工作号] `%`可省略，工作号用`jobs`查看
    + 同样该工作不能与前台有交互，否则还是暂停状态
- 有些工作我们不希望再关闭终端后就结束，所以要脱离终端。 有三种脱离终端的方法
    + 把需要后台执行的命令加入`/etc/rc.loacl`文件
    + 使用定时任务，让系统在某时间执行某个后台命令
    + `nohup [命令] &` 使命令脱离终端(也可以是脚本)。

### 查看系统资源
#### vmstat监控系统资源
- `vmstat [刷新延时 刷新次数]` 监控系统资源(单位：秒)。如`vmstat 1 3`
- `procs` 进程信息字段
    + `r` 等待运行的进程数，数量越大，系统越繁忙
    + `b` 不可被唤醒的进程数，数量越大，系统越繁忙
- `memory` 内存信息字段(单位KB)
    + `swpd` 虚拟内存的使用情况
    + `free` 空闲的内存容量
    + `buffer` 缓冲的内存容量(加速数据写入)
    + `cache` 缓存的内存容量(加速数据读取)
- `swap` 交换分区的信息字段(单位KB)
    + `si` 从磁盘中交换到内存中数据量
    + `so` 从内存中交换到磁盘中的数据量
    + 这两个数越大，证明数据需要经常再磁盘和内存之间交换，系统性能越差
- `io` 磁盘读写信息字段(单位 块) 
    + `bi` 从块设备读入的数据量
    + `bo` 写入到块设备的数据量
    + 此两个数越大，代表系统I/O越繁忙
- `system` 系统信息字段
    + `in` 每秒被中断的进程次数
    + `cs` 每秒进行的事件切换次数
    + 此两个数越大，代表系统与接口设备的通信越繁忙
- `CPU` CPU信息字段(百分比)
    + `us` 非内核进程消耗CPU运算时间的百分比
    + `sy` 内核进程消耗CPU运算时间的百分比
    + `id` 空闲CPU的占比
    + `wa` 等待I/O所消耗的CPU占比
    + `st` 被虚拟机所盗用的CPU占比

#### free
- `free [option]` 查看内存使用状态
    + `-b` 以字节为单位显示
    + `-k` 以KB为单位显示(默认就是KB)
    + `-m` 以MB为单位显示
    + `-g` 以GB为单位显示
- 展示内容第一行与第三行都很容易懂，就解释下第二行内容
    + `-/buffers/cache`的内存数，相当于第一行的`userd - buffers - cached`
    + `+/buffers/cache`的内存数，相当于第一行的`free + buffers + cached`

#### dmesg
- `dmesg` 开机时内核检测信息。内容多，可与grep命令连用如`dmesg | grep CPU`判断CPU(某个硬件)状态

#### 查看CPU信息
- `cat /proc/cpuinfo` 直接查看cpu文件信息

#### uptime
- `uptime` 显示系统的启动时间与平均负载，也就是top命令第一行，使用`w`命令也可以查看这个数据

#### uname
- `uname [option]` 查看系统于内核相关信息
    + `-a` 查看系统所有相关信息
    + `-r` 查看内核版本
    + `-s` 查看内核名称

#### 判断系统位数
- `file /bin/ls` 用`file`查看任意外部命令会得到位数

#### 查询当前系统的发行版本
- `lsb_release -a` 查询当前系统的发行版本
- `cat /etc/issue.net`

#### lsof
- `lsof [option]` 列出进程打开的文件
    + `-c 字符串` 只列出以字符串开头的进程打开的文件
    + `-u 用户名` 只列出某个用户的进程打开的问及那
    + `-p pid` 列出某个PID打开的文件
- `lsof | more` 内容过多可于`more`连用查看所有进程调用的文件
- `lsof /sbin/init` 查询`/sbin/init`(必须是系统文件)被哪个进程调用
- `lsof -c http` 查询httpd进程调用了哪些文件
- `lsof -u root` 查询root用户调用了哪些文件


### 定时任务
#### at 一次性定时任务
- 检查安装
    + `chkconfig --list | grep atd` 判断是否安装atd服务
    + `service atd restart` 启动atd服务
- 访问控制
    + `/etc/at.deny`黑名单，写入其中的用户无法使用at,对root不起作用
    + `/etc/at.allow`白名单，写入其中用户可使用at,本文件会覆盖`at.deny`
    + 若其都不存再，那么只有root用户可以使用at命令。
- `at [option] time` 其中`[option]`如下
    + `-m` 当at完成工作后无论是否有命令输出，都用email通知执行at命令的用户
    + `-c 工作号` 显示该at工作的实际内容
- `at [option] time` 其中`time`如下
    + `HH:MM` 如`02:30`
    + `HH:MM YYYY-MM-DD` 如`02:30 2013-01-01`
    + `HH:MM[am|pm] [month] [date]` 如`02:30 July 01`
    + `HH:MM[am|pm]+[minutes|hours|days|weeks]` 如`now + 5 minutes`
- `at now + 5 minutes` 执行命令后进入标准输入，写入文件名或命令后`ctrl+d`保存退出。
    + 退格键不能用时使用`ctrl`退格
- `atq` 查询已有的at任务
- `atrm [工作号]` 删除指定的at任务
- `at -c 工作号` 查询该at任务详细信息

#### crontab 循环定时任务
- 检查安装(这次用systemd工具)
    + `systemctl list-unit-files | grep crond` 判断是否安装atd服务
    + `systemctl start crond` 启动atd服务
- 访问控制
    + `/etc/cron.deny`黑名单，写入其中的用户无法使用cron,对root不起作用
    + `/etc/cron.allow`白名单，写入其中用户可使用cron,本文件会覆盖`cron.deny`
    + 若两文件都不存再，那么只有root用户可以使用at命令。
- `crontab [option]` 操作用户定时任务
    + `-e` 编辑crontab定时任务
    + `-l` 查询crontab定时任务
    + `-r` 删除当前用户所有的crontab定时任务
- `crontab -e`编辑格式:`* * * * * command`,其中每个`*`占用的位置都有其意义
    1. `0-59` 一小时中的第几分钟 
    2. `0-23` 一天中的第几小时
    3. `1-31` 一月中的第几天
    4. `1-12` 一年中的第几月
    5. `0-7` 一周中的星期几 其中0于7都代表星期日
- 编辑格式中的特殊符号，下面都已第一个占位为例(第几分钟)
    + `*` 代表该位置每一个时间周期都执行一次命令，如5个`*`就是每分钟执行
    + `n,m` 代表不连续时间周期内执行。 如示例为分别在第n和第m分钟执行
    + `n-m` 代表连续时间周期内每一周期执行。 如示例为分别在第n至第m分钟每分钟都执行
    + `*/n` 代表多久执行一次，如示例为每隔n分钟执行一次
- 使用`crontab`注意事项
    + 定时任务的`$PATH`与用户的`$PATH`不一样，所以命令/脚本最好写绝对路径
    + 定时任务最小周期是分钟，最大周期是月
- `/var/spool/cron/` 就是`crontab -e`命令所编辑的定时任务存放目录，该目录下的文件都以用户名命名

#### 全局性计划任务
- `crontab`命令会绑定用户有局限性，想要部署全局计划任务要用配置文件部署
- 编辑格式：`*  *  *  *  * user-name command` (要指明用户名)
- `/etc/crontab` 是全局性计划任务配置文件。
    + 全局计划任务有可能同一计划执行多个脚本，全放在`/etc/crontab`中逻辑不清晰，更建议使用`/etc/cron.d`目录进行管理
- `/etc/cron.d/` 全局性计划任务配置文件管理目录
    + 在此目录下创建多个`plan`文件包含多个定时任务，这样管理起来更清晰

#### anacron
- 若机器关机定时任务就无法执行。 `anacron`就是为了解决这种难题产生的。
- `/etc/cron.{daily,weekly,monthly}/`目录用于存放定时执行的脚本。其中错过执行时间的定时任务会被执行
- `/var/spool/anacron/cron.{daily,weekly,monthly}`三文件用于记录上次执行`/etc/cron.{hourly,daily,weekly,monthly}/*.sh`的时间
- 错过的定时任务检测周期是一天，一周，一月。在检测时取执行cron的时间与当前时间做比较，若时间差超过了anacron的指定时间差，证明有crond任务被漏执行

```shell
# 指定shell类型
SHELL=/bin/sh
# 指定环境变量
PATH=/sbin:/bin:/usr/sbin:/usr/bin
# 若漏执行选择发邮件的用户
MAILTO=root
# 错峰执行，随机延迟不超过45分钟
RANDOM_DELAY=45
# 漏执行任务的执行时间范围(3:00-22:00)
START_HOURS_RANGE=3-22
#天数     强制延迟(单位分)   工作名称        实际执行的命令
1         5                cron.daily      nice run-parts /etc/cron.daily
7         25               cron.weekly     nice run-parts /etc/cron.weekly
@monthly  45               cron.monthly    nice run-parts /etc/cron.monthly
```

- `/etc/anacrontab` 是`anacron`的配置文件 以第一行为例解读配置文件
    + 首先读取`/var/spool/anacron/cron.daily`中的上一次anacron执行时间 和当期时间比较，如果两个时间差超过1天，则执行cron.daily工作
    + 执行这个工作只能在03:00-22:00之间
    + 执行工作时强制延迟时间为5分钟，在随机延迟0-45分钟
    + 使用nice命令指定默认优先级，使用run-parts脚本执行`/etc/cron.daily`目录中的所有可执行文件

#### `/etc/cron.hourly/`文件
- `/etc/cron.hourly/` 时存放每小时执行脚本的目录，但执行方式不同与anacron
- 通过`/etc/cron.d/0hourly`文件执行`/etc/cron.hourly/`中的定时脚本
- 为什么`/etc/cron.hourly/*.sh`不也通过anacron执行?
    + 每小时执行消耗资源
    + anacron是有延迟的，一天一次的检测都有5-50分钟的延迟，何不等到开机后1小时在执行